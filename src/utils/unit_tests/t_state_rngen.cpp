/******************************************************************************
 *                                                                            *
 *    Copyright 2023   Lawrence Livermore National Security, LLC and other    *
 *    Whole Cell Simulator Project Developers. See the top-level COPYRIGHT    *
 *    file for details.                                                       *
 *                                                                            *
 *    SPDX-License-Identifier: MIT                                            *
 *                                                                            *
 ******************************************************************************/

#if defined(DR_EVT_HAS_CONFIG)
#include "dr_evt_config.hpp"
#else
#error "no config"
#endif

#include <iostream>
#include <sstream>
#include <cstdint>
#include "utils/rngen.hpp"
#include "utils/state_io.hpp"

#if defined(DR_EVT_HAS_CATCH2)
#include <cstddef>
#define CATCH_CONFIG_MAIN
#include "catch2/catch.hpp"
#endif // defined(DR_EVT_HAS_CATCH2)

enum MethodT {Cereal, Bits};
enum StreamBufT {StreamVec, StreamBuff, StringStream};

template <typename RNGenT,
          typename CharT = char,
          typename Traits = std::char_traits<CharT> >
std::basic_ostream<CharT, Traits>&
save_state_os(const RNGenT& rgen,
              const MethodT method,
              std::basic_ostream<CharT, Traits>& os)
{
    if (method == Cereal) {
      #if defined(DR_EVT_HAS_CEREAL)
        cereal::BinaryOutputArchive oarchive(os);
        oarchive(rgen); // Write the data to the archive
      #endif // defined(DR_EVT_HAS_CEREAL)
    } else {
        rgen.save_bits(os);
    }
    return os;
}

template <typename RNGenT,
          typename CharT = char,
          typename Traits = std::char_traits<CharT> >
std::basic_istream<CharT, Traits>&
load_state_is(RNGenT& rgen,
              const MethodT method,
              std::basic_istream<CharT, Traits>& is)
{
    if (method == Cereal) {
      #if defined(DR_EVT_HAS_CEREAL)
        cereal::BinaryInputArchive iarchive(is);
        iarchive(rgen); // Write the data to the archive
      #endif // defined(DR_EVT_HAS_CEREAL)
    } else {
        rgen.load_bits(is);
    }
    return is;
}

template <typename RNGenT>
bool save_to_streamvec(const MethodT method,
                       const RNGenT& rgen,
                       std::vector<char>& buf,
                       const size_t space_to_reserve = 0ul)
{
    buf.reserve(space_to_reserve);

    // dump the serialized rgen state into buf
    dr_evt::ostreamvec<char> ostrmbuf(buf);
    std::ostream os(&ostrmbuf);
    save_state_os(rgen, method, os);
    return os.good();
}

template <typename RNGenT>
bool save_to_streambuff(const MethodT method,
                        const RNGenT& rgen,
                        char* buf,
                        size_t capacity_preallocated)
{
    // dump the serialized rgen state into buf
    dr_evt::ostreambuff<char> ostrmbuf(buf, capacity_preallocated);
    std::ostream os(&ostrmbuf);
    save_state_os(rgen, method, os);
    return os.good();
}

template <typename RNGenT>
bool load_from_streamvec(const MethodT method,
                         RNGenT& rgen,
                         const std::vector<char>& buf)
{
    // dump the serialized rgen state into buf
    dr_evt::istreamvec<char> istrmbuf(buf);
    std::istream is(&istrmbuf);
    load_state_is(rgen, method, is);
    return is.good();
}

template <typename RNGenT>
bool load_from_streambuff(const MethodT method,
                          RNGenT& rgen,
                          char* buf,
                          size_t capacity_preallocated)
{
    // dump the serialized rgen state into buf
    dr_evt::istreambuff<char> istrmbuf(buf, capacity_preallocated);
    std::istream is(&istrmbuf);
    load_state_is(rgen, method, is);
    return is.good();
}

/**
 * \test Test save/load the state of #dr_evt::RNGen using Cereal or Bits
 * serialization method toghether with #dr_evt::streamvec or dr_evt::streambuf
 * buffering. The test is to generate some number of random numbers using one
 * RNGen object first. Then, save the staete of the object, and load it into
 * another RNGen object. Finally, compare the two sequences of random numbers
 * further generated by the two RNGen objects. When they are identical, retun
 * true. Otherwise, return false.
 *
 * \tparam<RNGenT>{, the first template parameter, is the type of dr_evt::RNGen object.
 * This class consists of members of various types including boolean, integer,
 * vector, and rng engine, std::distribution structure.}
 *
 * @param[in] p is the distribution parameter to initialize RNGen object.
 * @param[in] method indicates which serialization method to use.
 * @param[in] buftype indicates which buffering mechanism to use.
 * @param[out] sstr outputs the random number sequences compared.
 * @param[in] reserve_space indicates whether to reserve space in advance when
 * using #dr_evt::streamvec. The default is true.
 */
template<typename RNGenT, typename RNGenParamT = typename RNGenT::param_type>
inline bool test_RNGen_state_io(const RNGenParamT& p,
                                const MethodT method,
                                const StreamBufT buftype,
                                std::stringstream& sstr,
                                const bool reserve_space = true)
{
  #if !defined(DR_EVT_HAS_CEREAL)
    if (method == Cereal) {
        std::cerr << "Cereal is not enabled!" << std::endl;
        return false;
    }
  #endif // defined(DR_EVT_HAS_CEREAL)

    static_assert(std::is_same<typename RNGenT::param_type, RNGenParamT>::value,
                                "Invalid paramter type");

    // number of random numbers to show before making copy
    size_t n_before = 4;
    size_t n_after = 4;

    RNGenT rgen;
    RNGenT rgen2;
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    rgen.use_seed_seq({seed, 47u});
    //rgen.set_seed(seed);
    rgen.param(p);

    std::string rnseq1;
    std::string rnseq2;

    sstr << "Duplicate after " << n_before << " pulls" << std::endl;
    sstr << "RNG original    :";
    size_t head_len = sstr.str().size();

    for (size_t i = 0ul; i < n_before; i++) {
        sstr << ' ' << rgen();
    }

    bool ok_o = false;
    bool ok_i = false;
    std::vector<char> buf;
    std::stringstream sstrm;

    if (buftype == StreamVec) {
        if (reserve_space) {
            buf.reserve(rgen.byte_size());
            // buf.resize(rgen.byte_size()) also works for ostream.
            // However, only reserve() works for iostream because if
            // the buffer is not empty, iostream will read data from it.
        }
        ok_o = save_to_streamvec(method, rgen, buf);
    } else if (buftype == StreamBuff) {
        // Pretend that buf is a C-stype array
        size_t capacity = rgen.byte_size()*2; // enough to cover alignment padding
        buf.resize(capacity);
        ok_o = save_to_streambuff(method, rgen, buf.data(), capacity);
    } else if (buftype == StringStream) {
        save_state_os(rgen, method, sstrm);
        ok_o = sstrm.good();
    }
    if (!ok_o) return false;

    for (size_t i = 0ul; i < n_after; i++) {
        rnseq1 += ' ' + std::to_string(rgen());
    }
    size_t space_len = sstr.str().size();
    sstr << rnseq1 << std::endl;

    sstr << "RNG duplicate :";
    if (buftype == StreamVec) {
        ok_i = load_from_streamvec(method, rgen2, buf);
    } else if (buftype == StreamBuff) {
        // Pretend that buf is a C-stype array
        ok_i = load_from_streambuff(method, rgen2, buf.data(), buf.size());
    } else if (buftype == StringStream) {
        load_state_is(rgen2, method, sstrm);
        ok_i = sstrm.good();
    }
    if (!ok_i) return false;

    sstr << std::string(space_len-head_len, ' ');

    for (size_t i = 0ul; i < n_after; i++) {
        rnseq2 += ' ' + std::to_string(rgen2());
    }
    sstr << rnseq2 << std::endl;

    return (rnseq1 == rnseq2);
}

#if defined(DR_EVT_HAS_CATCH2)
#define CHECK_RESULT REQUIRE(ok == true)
TEST_CASE( "RNGen State IO", "[state I/O]" )
#else
#define CHECK_RESULT \
            std::cout << sstr.str(); \
            std::cout << (ok? "PASS" : "FAILED") << std::endl << std::endl;
#define SECTION(T) std::cout << T << std::endl;

int main (int argc, char** argv)
#endif
{
    using rng_uint_t = dr_evt::RNGen<std::uniform_int_distribution, unsigned>;
    using rng_double_t = dr_evt::RNGen<std::uniform_real_distribution, double>;

    bool ok = false;

    // StreamVec
    SECTION("Save and load the state of RNGen based on integer type uniform "
            "distribution using Cereal and StreamVec")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
                                             Cereal, StreamVec, sstr);
        CHECK_RESULT;
    }

    SECTION("Save and load the state of RNGen based on real type uniform "
            "distribution using Cereal and StreamVec")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
                                               Cereal, StreamVec, sstr);
        CHECK_RESULT;
    }
    SECTION("Save and load the state of RNGen based on integer type uniform "
            "distribution using the DR_EVT native method Bits and StreamVec")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
                                             Bits, StreamVec, sstr);
        CHECK_RESULT;
    }
    SECTION("Save and load the state of RNGen based on real type uniform "
            "distribution using the DR_EVT native method Bits and StreamVec")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
                                               Bits, StreamVec, sstr);
        CHECK_RESULT;
    }

    // StreamBuff
    SECTION("Save and load the state of RNGen based on integer type uniform "
            "distribution using Cereal and StreamBuff")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
                                             Cereal, StreamBuff, sstr);
        CHECK_RESULT;
    }
    SECTION("Save and load the state of RNGen based on real type uniform "
            "distribution using Cereal and StreamBuff")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
                                               Cereal, StreamBuff, sstr);
        CHECK_RESULT;
    }
    SECTION("Save and load the state of RNGen based on integer type uniform "
            "distribution using the DR_EVT native method Bits and StreamBuff")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
                                             Bits, StreamBuff, sstr);
        CHECK_RESULT;
    }
    SECTION("Save and load the state of RNGen based on real type uniform "
            "distribution using the DR_EVT native method Bits and StreamBuff")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
                                               Bits, StreamBuff, sstr);
        CHECK_RESULT;
    }

    // std::stringstream
    SECTION("Save and load the state of RNGen based on integer type uniform "
            "distribution using Cereal and std::stringstream")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
                                             Cereal, StringStream, sstr);
        CHECK_RESULT;
    }
    SECTION("Save and load the state of RNGen based on real type uniform "
            "distribution using Cereal and std::stringstream")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
                                               Cereal, StringStream, sstr);
        CHECK_RESULT;
    }
    SECTION("Save and load the state of RNGen based on integer type uniform "
            "distribution using the DR_EVT native method Bits and std::stringstream")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
                                             Bits, StringStream, sstr);
        CHECK_RESULT;
    }
    SECTION("Save and load the state of RNGen based on real type uniform "
            "distribution using the DR_EVT native method Bits and std::stringstream")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_double_t>(rng_double_t::param_type(0.0, 1.0),
                                               Bits, StringStream, sstr);
        CHECK_RESULT;
    }

    // StreamVec with no space reservation
    SECTION("Save and load the state of RNGen based on integer type uniform "
            "distribution using Cereal and StreamVec withtout space reservation")
    {
        std::stringstream sstr;
        ok = test_RNGen_state_io<rng_uint_t>(rng_uint_t::param_type(100, 999),
                                             Cereal, StreamVec, sstr, false);
        CHECK_RESULT;
    }
#if !defined(DR_EVT_HAS_CATCH2)
    return 0;
#endif
}
